# generated by fastapi-codegen:
#   filename:  fridgefreak-api_OAS3.yaml
#   timestamp: 2024-06-06T14:21:29+00:00

from __future__ import annotations

from datetime import date
from typing import Any, List, Optional, Union

from contextlib import asynccontextmanager
import fridgefreak_api.database as db

from fastapi import FastAPI, Query, APIRouter, HTTPException

from fridgefreak_api.models import (
    Product,
    StorageDeleteRequest,
    StorageGetResponse,
    ProductNotFoundResponse,
)

# this will connect to the db at the app start 
# and when app stops it will continue executing effectively disconnecting from db
@asynccontextmanager
async def lifespan(app: FastAPI):
    db.connection.connect()
    yield
    db.connection.close()


app = FastAPI(
    title="FridgeFreak-api",
    version="1.2.0",
    lifespan=lifespan
)

mysql_cursor = db.connection.cursor(dictionary=True)


router = APIRouter(prefix="/api")

@router.get("/storage", response_model=StorageGetResponse)
async def g_e_t_storage(
    name: Optional[str] = None,
    storage_space: Optional[str] = None,
    category: Optional[str] = None,
    quantity: Optional[int] = None,
    expire2date: Optional[date] = None,
) -> StorageGetResponse:
    where = ""
    if name: where += f" AND (name = {name})"
    if storage_space: where += f" AND (storage_space = {storage_space})"
    if category: where += f" AND (category = {category})"
    if quantity:where += f" AND (quantity = {quantity})"

    sql = "SELECT * FROM products WHERE 1=1" + where
    
    mysql_cursor.execute(sql)
    products = await mysql_cursor.fetchall()

    return {
                "result_count": len(products),
                "products": products
            }

@router.post("/storage", response_model=None, status_code=201)
def p_o_s_t_storage(body: List[Product]) -> Any:

    sql = f"INSERT INTO products (name, quantity, category, storage_space, expire_by) VALUES (%s,%s,%s,%s,%s)"
    values = []
    for p in body:
        values.append((p.name, p.quantity, str(p.category), str(p.storage_space), p.expire_by))

    mysql_cursor.executemany(sql, values)
    db.connection.commit()
        
    return {"message": f"Added {mysql_cursor.rowcount} products"}


@router.delete("/storage", response_model=Any, responses={"500": {"model": Any}})
def d_e_l_e_t_e_storage(
    in_database: bool = Query(..., alias="in-database"),
    body: StorageDeleteRequest = ...,
) -> Any:
    return [body , "in-database: " + str(in_database)]



@router.get(
    "/storage/{id}",
    response_model=Product,
    responses={"404": {"model": ProductNotFoundResponse}},
)
async def g_e_t_storage_id(id: int) -> Union[Product, ProductNotFoundResponse]:
    
    mysql_cursor.execute(f"SELECT * FROM products WHERE id={id};")
    ret = mysql_cursor.fetchone()
    return ret


@router.delete(
    "/storage/{id}",
    response_model=Any,
    responses={"404": {"model": ProductNotFoundResponse}},
)
def d_e_l_e_t_e_storage_id(id: float) -> Union[Any, ProductNotFoundResponse]:
    pass


@router.put(
    "/storage/{id}",
    response_model=Any,
    responses={"404": {"model": ProductNotFoundResponse}},
)
def p_u_t_storage_id(
    id: float, body: Product = ...
) -> Union[Any, ProductNotFoundResponse]:
    pass


app.include_router(router)