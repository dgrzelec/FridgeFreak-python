# generated by fastapi-codegen:
#   filename:  fridgefreak-api_OAS3.yaml
#   timestamp: 2024-06-06T14:21:29+00:00

from __future__ import annotations

from datetime import date
from typing import Any, List, Optional, Union

from contextlib import asynccontextmanager
import fridgefreak_api.database as db

from fastapi import FastAPI, Query, APIRouter, HTTPException

from fridgefreak_api.models import (
    Product,
    StorageDeleteRequest,
    StorageGetResponse,
    ProductNotFoundResponse,
)

from fridgefreak_api.config import config

# this will connect to the db at the app start 
# and when app stops it will continue executing effectively disconnecting from db
@asynccontextmanager
async def lifespan(app: FastAPI):
    db.connection.connect()
    yield
    db.connection.close()


app = FastAPI(
    title="FridgeFreak-api",
    version="1.2.0",
    lifespan=lifespan
)

mysql_cursor = db.connection.cursor(dictionary=True)


router = APIRouter(prefix="/api")

###############
###############
###############

@router.get("/storage", response_model=StorageGetResponse)
async def g_e_t_storage(
    name: Optional[str] = None,
    storage_space: Optional[str] = None,
    category: Optional[str] = None,
    quantity: Optional[int] = None,
    expire2date: Optional[date] = None,
) -> StorageGetResponse:
    where = ""
    if name: where += f" AND (name = '{name}')"
    if storage_space: where += f" AND (storage_space = '{storage_space}')"
    if category: where += f" AND (category = '{category}')"
    if quantity:where += f" AND (quantity = '{quantity}')"

    sql = f"SELECT * FROM {config.TABLE_NAME} WHERE 1=1" + where
    
    mysql_cursor.execute(sql)
    products = mysql_cursor.fetchall()

    if not products:
        raise HTTPException(status_code=404, detail="No product was found matching criteria")

    return {
                "result_count": len(products),
                "products": products
            }

@router.post("/storage", response_model=None, status_code=201)
def p_o_s_t_storage(body: List[Product]) -> Any:

    sql = f"INSERT INTO {config.TABLE_NAME} (name, quantity, category, storage_space, expire_by) VALUES (%s,%s,%s,%s,%s)"
    values = []
    for p in body:
        values.append((p.name, p.quantity, str(p.category), str(p.storage_space), p.expire_by))

    mysql_cursor.executemany(sql, values)
    db.connection.commit()
        
    return {"message": f"Added {mysql_cursor.rowcount} products"}


@router.delete("/storage", response_model=Any)
def d_e_l_e_t_e_storage(
    in_database: bool = Query(..., alias="in-database"),
    body: StorageDeleteRequest = ...,
) -> Any:
    # find queried product
    where = ""
    if body.name: where += f" AND (name = '{body.name}')"
    if body.storage_space: where += f" AND (storage_space = '{body.storage_space}')"
    if body.category: where += f" AND (category = '{body.category}')"
    if body.expire_by:where += f" AND (expire_by = '{body.expire_by}')"

    sql = f"SELECT * FROM {config.TABLE_NAME} WHERE 1=1" + where
    
    mysql_cursor.execute(sql)
    product = mysql_cursor.fetchall()

    if len(product) == 0:
        raise HTTPException(status_code=404, detail="No product was found matching criteria")
    if len(product) > 1:
        raise HTTPException(status_code=500, detail="Ambiguous request: Multiple products match criteria")

    prod_id = product[0]["id"]
    # zero quantity
    if not in_database:
        sql = f"UPDATE {config.TABLE_NAME} SET quantity=0 WHERE id={prod_id}"
        mysql_cursor.execute(sql)
        db.connection.commit()

        return {"message": f"Quantity of product with id {prod_id} set to zero"}
    # delete from db
    else:
        sql = f"DELETE FROM {config.TABLE_NAME} WHERE id={prod_id}"
        mysql_cursor.execute(sql)
        db.connection.commit()
        
        return {"message": f"Product with id {prod_id} deleted",
                "id": prod_id}



@router.get(
    "/storage/{id}",
    response_model=Product,
    responses={"404": {"model": ProductNotFoundResponse}},
)
async def g_e_t_storage_id(id: int) -> Union[Product, ProductNotFoundResponse]:
    
    mysql_cursor.execute(f"SELECT * FROM {config.TABLE_NAME} WHERE id={id};")
    ret = mysql_cursor.fetchone()

    if not ret:
        raise HTTPException(status_code=404, detail="Product not found")
    
    return ret


@router.delete(
    "/storage/{id}",
    response_model=Any,
)
def d_e_l_e_t_e_storage_id(id: int) -> Any:
    
    sql = f"DELETE FROM {config.TABLE_NAME} WHERE id={id}"
    mysql_cursor.execute(sql)
    
    if mysql_cursor.rowcount == 0:
        raise HTTPException(status_code=404, detail="Product not found")

    db.connection.commit()
    # db.connection.rollback()

    return {"message": f"Product with id {id} deleted"}


@router.put(
    "/storage/{id}",
    response_model=Any,
    responses={"404": {"model": ProductNotFoundResponse}},
)
def p_u_t_storage_id(
    id: float, body: Product = ...
) -> Union[Any, ProductNotFoundResponse]:
    pass


app.include_router(router)